From c15932fcb15042f3bc117bca31b16a01f81de9fe Mon Sep 17 00:00:00 2001
From: Marko Lindqvist <cazfi74@gmail.com>
Date: Thu, 22 Jun 2023 17:47:36 +0300
Subject: [PATCH 10/14] AI: Stop cancelling shared vision to team members

There are other side effects on the fixed checks
of team and/or alliance.

- AI no longer tries to declare war on a team member.
  While it couldn't do that before, it suffered some
  side-effects of preparing to war.

See osdn #48152

Signed-off-by: Marko Lindqvist <cazfi74@gmail.com>
---
 ai/default/daidiplomacy.c   | 81 ++++++++++++++++++++-----------------
 server/maphand.c            |  6 ++-
 server/savegame/savegame2.c | 22 ++++++++++
 server/savegame/savegame3.c | 21 ++++++++++
 4 files changed, 91 insertions(+), 39 deletions(-)

diff --git a/ai/default/daidiplomacy.c b/ai/default/daidiplomacy.c
index 2d1b224056..3736f0c6d6 100644
--- a/ai/default/daidiplomacy.c
+++ b/ai/default/daidiplomacy.c
@@ -1356,7 +1356,7 @@ static void dai_go_to_war(struct ai_type *ait, struct player *pplayer,
       /* Ooops! */
       DIPLO_LOG(ait, LOG_DIPL, pplayer, target, "Wanted to declare war "
                 "for their war against an ally, but can no longer find "
-                "this ally!  War declaration aborted.");
+                "this ally! War declaration aborted.");
       adip->countdown = -1;
       return;
     }
@@ -1597,6 +1597,7 @@ void dai_diplomacy_actions(struct ai_type *ait, struct player *pplayer)
           || pplayers_at_war(pplayer, aplayer)) {
         continue;
       }
+
       /* A spaceship victory is always one single player's or team's victory */
       if (aplayer->spaceship.state == SSHIP_LAUNCHED
           && adv->dipl.spacerace_leader == aplayer
@@ -1606,15 +1607,15 @@ void dai_diplomacy_actions(struct ai_type *ait, struct player *pplayer)
                            "yourself alone betrays your true intentions, and I "
                            "will have no more of our alliance!"),
                          player_name(pplayer));
-	handle_diplomacy_cancel_pact(pplayer, player_number(aplayer),
-				     CLAUSE_ALLIANCE);
+        handle_diplomacy_cancel_pact(pplayer, player_number(aplayer),
+                                     CLAUSE_ALLIANCE);
         if (gives_shared_vision(pplayer, aplayer)) {
           remove_shared_vision(pplayer, aplayer);
         }
         /* Never forgive this */
         pplayer->ai_common.love[player_index(aplayer)] = -MAX_AI_LOVE;
       } else if (ship->state == SSHIP_STARTED 
-		 && adip->warned_about_space == 0) {
+                 && adip->warned_about_space == 0) {
         pplayer->ai_common.love[player_index(aplayer)] -= MAX_AI_LOVE / 10;
         adip->warned_about_space = 10 + fc_rand(6);
         dai_diplo_notify(aplayer,
@@ -1704,22 +1705,24 @@ void dai_diplomacy_actions(struct ai_type *ait, struct player *pplayer)
   /*** Actually declare war (when we have moved units into position) ***/
 
   players_iterate(aplayer) {
-    struct ai_dip_intel *adip = dai_diplomacy_get(ait, pplayer, aplayer);
+    if (!players_on_same_team(pplayer, aplayer)) {
+      struct ai_dip_intel *adip = dai_diplomacy_get(ait, pplayer, aplayer);
 
-    if (!aplayer->is_alive) {
-      adip->countdown = -1;
-      continue;
-    }
-    if (adip->countdown > 0) {
-      adip->countdown--;
-    } else if (adip->countdown == 0) {
-      if (!WAR(pplayer, aplayer)) {
-        DIPLO_LOG(ait, LOG_DIPL2, pplayer, aplayer, "Declaring war!");
-        dai_go_to_war(ait, pplayer, aplayer, adip->war_reason);
+      if (!aplayer->is_alive) {
+        adip->countdown = -1;
+        continue;
+      }
+      if (adip->countdown > 0) {
+        adip->countdown--;
+      } else if (adip->countdown == 0) {
+        if (!WAR(pplayer, aplayer)) {
+          DIPLO_LOG(ait, LOG_DIPL2, pplayer, aplayer, "Declaring war!");
+          dai_go_to_war(ait, pplayer, aplayer, adip->war_reason);
+        }
+      } else if (adip->countdown < -1) {
+        /* Negative countdown less than -1 is war stubbornness */
+        adip->countdown++;
       }
-    } else if (adip->countdown < -1) {
-      /* negative countdown less than -1 is war stubbornness */
-      adip->countdown++;
     }
   } players_iterate_end;
 
@@ -1740,7 +1743,8 @@ void dai_diplomacy_actions(struct ai_type *ait, struct player *pplayer)
       if (gives_shared_vision(pplayer, aplayer)) {
         if (!pplayers_allied(pplayer, aplayer)) {
           remove_shared_vision(pplayer, aplayer);
-        } else if (!shared_vision_is_safe(pplayer, aplayer)) {
+        } else if (!players_on_same_team(pplayer, aplayer)
+                   && !shared_vision_is_safe(pplayer, aplayer)) {
           dai_diplo_notify(aplayer,
                            _("*%s (AI)* Sorry, sharing vision with you "
                              "is no longer safe."),
@@ -1828,26 +1832,27 @@ void dai_diplomacy_actions(struct ai_type *ait, struct player *pplayer)
                                player_name(target));
               adip->ally_patience--;
             }
-          } else {
-            if (fc_rand(5) == 1) {
-              dai_diplo_notify(aplayer,
-                               _("*%s (AI)* Dishonored one, we made a pact of "
-                                 "alliance, and yet you remain at peace with our mortal "
-                                 "enemy, %s! This is unacceptable; our alliance is no "
-                                 "more!"),
-                               player_name(pplayer),
-                               player_name(target));
-              DIPLO_LOG(ait, LOG_DIPL2, pplayer, aplayer, "breaking useless alliance");
-              /* to peace */
-              handle_diplomacy_cancel_pact(pplayer, player_number(aplayer),
-                                           CLAUSE_ALLIANCE);
-              pplayer->ai_common.love[player_index(aplayer)] =
-                MIN(pplayer->ai_common.love[player_index(aplayer)], 0);
-              if (gives_shared_vision(pplayer, aplayer)) {
-                remove_shared_vision(pplayer, aplayer);
-              }
-              fc_assert(!gives_shared_vision(pplayer, aplayer));
+          } else if (fc_rand(5) == 1
+                     && !players_on_same_team(pplayer, aplayer)) {
+            dai_diplo_notify(aplayer,
+                             _("*%s (AI)* Dishonored one, we made a pact of "
+                               "alliance, and yet you remain at peace with our mortal "
+                               "enemy, %s! This is unacceptable; our alliance is no "
+                               "more!"),
+                             player_name(pplayer),
+                             player_name(target));
+            DIPLO_LOG(ait, LOG_DIPL2, pplayer, aplayer,
+                      "breaking useless alliance");
+            /* To peace */
+            handle_diplomacy_cancel_pact(pplayer, player_number(aplayer),
+                                         CLAUSE_ALLIANCE);
+            pplayer->ai_common.love[player_index(aplayer)]
+              = MIN(pplayer->ai_common.love[player_index(aplayer)], 0);
+            if (gives_shared_vision(pplayer, aplayer)) {
+              remove_shared_vision(pplayer, aplayer);
             }
+
+            fc_assert(!gives_shared_vision(pplayer, aplayer));
           }
         }
         break;
diff --git a/server/maphand.c b/server/maphand.c
index a61fdd4cee..4702ad7da2 100644
--- a/server/maphand.c
+++ b/server/maphand.c
@@ -1603,7 +1603,11 @@ static void create_vision_dependencies(void)
 void give_shared_vision(struct player *pfrom, struct player *pto)
 {
   bv_player save_vision[player_slot_count()];
-  if (pfrom == pto) return;
+
+  if (pfrom == pto) {
+    return;
+  }
+
   if (gives_shared_vision(pfrom, pto)) {
     log_error("Trying to give shared vision from %s to %s, "
               "but that vision is already given!",
diff --git a/server/savegame/savegame2.c b/server/savegame/savegame2.c
index ee1920de03..9e5e82cadb 100644
--- a/server/savegame/savegame2.c
+++ b/server/savegame/savegame2.c
@@ -2796,11 +2796,13 @@ static void sg_load_players(struct loaddata *loading)
     BV_CLR_ALL(pplayer->server.really_gives_vision);
   } players_iterate_end;
 
+  /* Set up shared vision... */
   players_iterate(pplayer) {
     int plr1 = player_index(pplayer);
 
     players_iterate(pplayer2) {
       int plr2 = player_index(pplayer2);
+
       if (secfile_lookup_bool_default(loading->file, FALSE,
               "player%d.diplstate%d.gives_shared_vision", plr1, plr2)) {
         give_shared_vision(pplayer, pplayer2);
@@ -2808,6 +2810,26 @@ static void sg_load_players(struct loaddata *loading)
     } players_iterate_end;
   } players_iterate_end;
 
+  /* ...and check it */
+  players_iterate(pplayer1) {
+    players_iterate(pplayer2) {
+      if (players_on_same_team(pplayer1, pplayer2)) {
+        if (!really_gives_vision(pplayer1, pplayer2)) {
+          sg_regr(3000900,
+                  _("%s did not give shared vision to team member %s."),
+                  player_name(pplayer1), player_name(pplayer2));
+          give_shared_vision(pplayer1, pplayer2);
+        }
+        if (!really_gives_vision(pplayer2, pplayer1)) {
+          sg_regr(3000900,
+                  _("%s did not give shared vision to team member %s."),
+                  player_name(pplayer2), player_name(pplayer1));
+          give_shared_vision(pplayer2, pplayer1);
+        }
+      }
+    } players_iterate_end;
+  } players_iterate_end;
+
   initialize_globals();
   unit_ordering_apply();
 
diff --git a/server/savegame/savegame3.c b/server/savegame/savegame3.c
index 809a2bdc39..2524f51369 100644
--- a/server/savegame/savegame3.c
+++ b/server/savegame/savegame3.c
@@ -3895,6 +3895,7 @@ static void sg_load_players(struct loaddata *loading)
     BV_CLR_ALL(pplayer->server.really_gives_vision);
   } players_iterate_end;
 
+  /* Set up shared vision... */
   players_iterate(pplayer) {
     int plr1 = player_index(pplayer);
 
@@ -3912,6 +3913,26 @@ static void sg_load_players(struct loaddata *loading)
     } players_iterate_end;
   } players_iterate_end;
 
+  /* ...and check it */
+  players_iterate(pplayer1) {
+    players_iterate(pplayer2) {
+      if (players_on_same_team(pplayer1, pplayer2)) {
+        if (!really_gives_vision(pplayer1, pplayer2)) {
+          sg_regr(3000900,
+                  _("%s did not give shared vision to team member %s."),
+                  player_name(pplayer1), player_name(pplayer2));
+          give_shared_vision(pplayer1, pplayer2);
+        }
+        if (!really_gives_vision(pplayer2, pplayer1)) {
+          sg_regr(3000900,
+                  _("%s did not give shared vision to team member %s."),
+                  player_name(pplayer2), player_name(pplayer1));
+          give_shared_vision(pplayer2, pplayer1);
+        }
+      }
+    } players_iterate_end;
+  } players_iterate_end;
+
   initialize_globals();
   unit_ordering_apply();
 
-- 
2.40.1

